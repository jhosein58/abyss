use crate::target::Target;
use abyss_parser::ast::{BinaryOp, Type, UnaryOp};
use std::{collections::HashMap, fmt::Write};

pub struct CTarget {
    output: String,
    current_function_body: String,
    string_pool: Vec<String>,
    temp_counter: usize,
    label_counter: usize,
    indent_level: usize,
    in_function: bool,
    function_return_types: HashMap<String, Type>,
    current_function_name: String,
}

impl CTarget {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            current_function_body: String::new(),
            string_pool: Vec::new(),
            temp_counter: 0,
            label_counter: 0,
            indent_level: 0,
            in_function: false,
            function_return_types: HashMap::new(),
            current_function_name: String::new(),
        }
    }

    fn intern(&mut self, s: String) -> usize {
        let idx = self.string_pool.len();
        self.string_pool.push(s);
        idx
    }

    fn get(&self, idx: usize) -> &str {
        &self.string_pool[idx]
    }

    fn emit(&mut self, text: &str) {
        let indent = "    ".repeat(self.indent_level);
        if self.in_function {
            writeln!(self.current_function_body, "{}{}", indent, text).unwrap();
        } else {
            writeln!(self.output, "{}{}", indent, text).unwrap();
        }
    }

    fn next_label(&mut self) -> String {
        let name = format!("label_{}", self.label_counter);
        self.label_counter += 1;
        name
    }

    fn type_to_c(&self, ty: &Type) -> String {
        match ty {
            Type::I64 => "long long".to_string(),
            Type::U8 => "unsigned char".to_string(),
            Type::F64 => "double".to_string(),
            Type::Bool => "int".to_string(),
            Type::Void => "void".to_string(),
            Type::Pointer(inner) => format!("{}*", self.type_to_c(inner)),
            Type::Array(inner, size) => format!("{}[{}]", self.type_to_c(inner), size),
        }
    }

    pub fn get_code(&self) -> &str {
        &self.output
    }
}

impl Target for CTarget {
    type Value = usize;
    type Block = usize;

    fn start_program(&mut self) {
        self.output.clear();
        self.string_pool.clear();
        self.emit("#include <stdio.h>");
        self.emit("#include <stdlib.h>");
        self.emit("#include <stdint.h>");
        self.emit("#include <stdbool.h>");
        self.emit(
            r#"
void print(const unsigned char* data) {
    if (!data) return;

    while (*data) {
         putchar((char)*data);
        data++;
    }
}

void print_i64(long long x) {
    printf("%lld", x);
}

void print_f64(double x) {
    printf("%g", x);
}


"#,
        );
        self.emit("// --- Generated by Abyss CTarget ---");
        self.emit("");
    }

    fn end_program(&mut self) {}

    fn declare_extern_function(
        &mut self,
        name: &str,
        params: &[(String, Type)],
        return_type: Type,
    ) {
        let ret_c = self.type_to_c(&return_type);
        let params_c: Vec<String> = params.iter().map(|(_, ty)| self.type_to_c(ty)).collect();

        self.emit(&format!(
            "extern {} {}({});",
            ret_c,
            name,
            params_c.join(", ")
        ));
    }

    fn predefine_function(&mut self, name: &str, params: &[(String, Type)], return_type: Type) {
        self.function_return_types
            .insert(name.to_string(), return_type.clone());

        if name == "main" {
            self.emit("int main(void);");
            return;
        }

        let ret_c = self.type_to_c(&return_type);
        let params_c: Vec<String> = params.iter().map(|(_, ty)| self.type_to_c(ty)).collect();

        self.emit(&format!("{} {}({});", ret_c, name, params_c.join(", ")));
    }

    fn start_function(&mut self, name: &str) {
        self.current_function_body.clear();
        self.temp_counter = 0;
        self.label_counter = 0;
        self.in_function = true;
        self.current_function_name = name.to_string();

        self.emit(&format!("// Function Definition: {}", name));

        if name == "main" {
            self.current_function_body.push_str("int main(");
        } else {
            let ret_type = self.function_return_types.get(name).unwrap_or(&Type::Void);
            let ret_c = self.type_to_c(ret_type);
            self.current_function_body
                .push_str(&format!("{} {}(", ret_c, name));
        }
    }

    fn add_function_param(&mut self, name: &str, ty: Type) {
        if self.current_function_name == "main" {
            return;
        }

        if self.current_function_body.ends_with('(') {
        } else {
            self.current_function_body.push_str(", ");
        }
        let c_ty = self.type_to_c(&ty);
        self.current_function_body
            .push_str(&format!("{} {}", c_ty, name));
    }

    fn start_function_body(&mut self) {
        if self.current_function_name == "main" {
            if self.current_function_body.ends_with('(') {
                self.current_function_body.push_str("void");
            }
        }

        self.current_function_body.push_str(") {\n");
        self.indent_level += 1;
    }

    fn end_function(&mut self) {
        if self.current_function_name == "main" {
            let body_trim = self.current_function_body.trim_end();
            if !body_trim.ends_with("return 0;") {
                self.emit("return 0;");
            }
        }

        self.indent_level -= 1;
        self.current_function_body.push_str("}\n\n");
        self.output.push_str(&self.current_function_body);
        self.in_function = false;
        self.current_function_name.clear();
    }

    fn call_function(&mut self, name: &str, args: Vec<Self::Value>) -> Self::Value {
        let args_str: Vec<&str> = args.iter().map(|&id| self.get(id)).collect();
        let call_code = format!("{}({})", name, args_str.join(", "));
        self.intern(call_code)
    }

    fn return_value(&mut self, value: Self::Value) {
        let val_str = self.get(value).to_string();
        self.emit(&format!("return {};", val_str));
    }

    fn return_void(&mut self) {
        if self.current_function_name == "main" {
            self.emit("return 0;");
        } else {
            self.emit("return;");
        }
    }

    fn declare_variable(&mut self, name: &str, ty: Type, value: Option<Self::Value>) {
        if let Some(val_id) = value {
            let val_str = self.get(val_id);
            if let Type::Array(inner, _) = &ty {
                let c_type = self.type_to_c(inner);
                self.emit(&format!("{} {}[] = {};", c_type, name, val_str));
            } else {
                let c_type = self.type_to_c(&ty);
                self.emit(&format!("{} {} = {};", c_type, name, val_str));
            }
        } else {
            if let Type::Array(inner, size) = ty {
                let c_type = self.type_to_c(&inner);
                self.emit(&format!("{} {}[{}];", c_type, name, size));
            } else {
                let c_type = self.type_to_c(&ty);
                self.emit(&format!("{} {};", c_type, name));
            }
        }
    }

    fn get_variable_address(&mut self, name: &str) -> Self::Value {
        self.intern(format!("&{}", name))
    }

    fn store(&mut self, address: Self::Value, value: Self::Value) {
        let addr_str = self.get(address).to_string();
        let val_str = self.get(value).to_string();
        self.emit(&format!("*({}) = {};", addr_str, val_str));
    }

    fn load(&mut self, address: Self::Value) -> Self::Value {
        let addr_str = self.get(address).to_string();
        self.intern(format!("*({})", addr_str))
    }

    fn create_block(&mut self) -> Self::Block {
        let label = self.next_label();
        self.intern(label)
    }

    fn seal_block(&mut self, _block: Self::Block) {}

    fn switch_to_block(&mut self, block: Self::Block) {
        let label = self.get(block).to_string();
        writeln!(self.current_function_body, "{}:;", label).unwrap();
    }

    fn jump(&mut self, target_block: Self::Block) {
        let label = self.get(target_block).to_string();
        self.emit(&format!("goto {};", label));
    }

    fn branch(&mut self, condition: Self::Value, then_block: Self::Block, else_block: Self::Block) {
        let cond_str = self.get(condition).to_string();
        let then_label = self.get(then_block).to_string();
        let else_label = self.get(else_block).to_string();

        self.emit(&format!(
            "if ({}) goto {}; else goto {};",
            cond_str, then_label, else_label
        ));
    }

    fn translate_lit_int(&mut self, value: i64) -> Self::Value {
        self.intern(value.to_string())
    }

    fn translate_lit_float(&mut self, value: f64) -> Self::Value {
        let s = if value.fract() == 0.0 {
            format!("{}.0", value)
        } else {
            value.to_string()
        };
        self.intern(s)
    }

    fn translate_lit_bool(&mut self, value: bool) -> Self::Value {
        self.intern((if value { "1" } else { "0" }).to_string())
    }

    fn translate_lit_string(&mut self, value: &str) -> Self::Value {
        self.intern(format!("\"{}\"", value))
    }

    fn translate_lit_array(&mut self, values: Vec<Self::Value>, _: Type) -> Self::Value {
        let content: Vec<&str> = values.iter().map(|&id| self.get(id)).collect();
        self.intern(format!("{{ {} }}", content.join(", ")))
    }
    fn translate_ident(&mut self, name: &str) -> Self::Value {
        self.intern(name.to_string())
    }

    fn translate_binary_op(
        &mut self,
        op: BinaryOp,
        lhs: Self::Value,
        rhs: Self::Value,
    ) -> Self::Value {
        let l_str = self.get(lhs).to_string();
        let r_str = self.get(rhs).to_string();

        let op_str = match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::Eq => "==",
            BinaryOp::Neq => "!=",
            BinaryOp::Lt => "<",
            BinaryOp::Gt => ">",
            BinaryOp::Lte => "<=",
            BinaryOp::Gte => ">=",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
            BinaryOp::BitAnd => "&",
            BinaryOp::BitOr => "|",
            BinaryOp::BitXor => "^",
            BinaryOp::Shl => "<<",
            BinaryOp::Shr => ">>",
        };

        self.intern(format!("({} {} {})", l_str, op_str, r_str))
    }

    fn translate_unary_op(&mut self, op: UnaryOp, value: Self::Value) -> Self::Value {
        let v_str = self.get(value).to_string();
        let op_str = match op {
            UnaryOp::Not => "!",
            UnaryOp::Neg => "-",
            UnaryOp::BitNot => "~",
        };
        self.intern(format!("({}{})", op_str, v_str))
    }

    fn translate_cast(&mut self, value: Self::Value, target_type: Type) -> Self::Value {
        let v_str = self.get(value).to_string();
        let c_type = self.type_to_c(&target_type);
        self.intern(format!("(({}){})", c_type, v_str))
    }

    fn translate_index(&mut self, ptr: Self::Value, index: Self::Value) -> Self::Value {
        let p_str = self.get(ptr).to_string();
        let i_str = self.get(index).to_string();
        self.intern(format!("{}[{}]", p_str, i_str))
    }
    fn get_address_of_lvalue(&mut self, lvalue: Self::Value) -> Self::Value {
        let lvalue_str = self.get(lvalue);
        self.intern(format!("&({})", lvalue_str))
    }

    fn emit_expr_stmt(&mut self, value: Self::Value) {
        let val_str = self.get(value).to_string();
        self.emit(&format!("{};", val_str));
    }

    fn emit_value_string(&mut self, value: String) -> Self::Value {
        let wrapped = format!("(unsigned char[]){value}");
        let index = self.string_pool.len();
        self.string_pool.push(wrapped);
        index
    }
}
